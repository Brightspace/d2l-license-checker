#!/usr/bin/env node
'use strict';

// SPDX license IDs: https://spdx.org/licenses/

const checker = require('license-checker');
const bowerChecker = require('bower-license');
const _ = require('lodash');
const fs = require('fs');
const path = require('path');
const spdx = require('spdx');
const satisfies = require('spdx-satisfies');
const Promise = require('bluebird');
const semver = require('semver');

const defaultConfigFilePath = 'license-checker-ci.cfg';
const argv = require('yargs')
	.usage(
	'$0 [project-path [config-file-path]]\n\n' +
		'  If no project path is given, the current directory with be used\n' +
		`  If no config path is given, the file <project-path>/${defaultConfigFilePath} will be used as default.`)
	.help('h')
	.alias('h', 'help')
	.strict()
	.argv;
const projectDir = argv._[0] || process.cwd();
const configFilePath = path.resolve(argv._[1] || path.join(projectDir, defaultConfigFilePath));
const configAcceptedPackageManagers = ['npm', 'bower'];
const configAcceptedEntries = ['packageManager', 'acceptedLicenses', 'manualOverrides', 'acceptedScopes', 'ignoreUnusedManualOverrides'];
const spdxExceptions = ['Public-Domain', 'Project-Owner'];

let acceptedSpdxExpr;
let acceptedNonSpdx;
let config;
let projectPackage;

function handleError(err, code) {
	console.error('ERROR: ' + err.replace(/\n/g, '\n       '));
	/* eslint no-process-exit:0 */
	process.exit(code || 1);
}

function readConfig() {
	try {
		let data = fs.readFileSync(configFilePath, {encoding: 'utf8'});
		config = JSON.parse(data);
	} catch (err) {
		handleError(`Could not read config file at ${configFilePath}: ${err}`);
	}
	for (let key in config) {
		if (configAcceptedEntries.indexOf(key) < 0) {
			handleError(`${configFilePath}: "${key}" is not a valid entry (must be one of ${configAcceptedEntries}).`);
		}
	}
	if (config.packageManager && typeof config.packageManager !== 'string' && configAcceptedPackageManagers.includes(config.packageManager)) {
		handleError(`${configFilePath}: "packageManager" must be one of ${configAcceptedPackageManagers}`);
	}
	if (config.acceptedLicenses && !Array.isArray(config.acceptedLicenses)) {
		handleError(`${configFilePath}: "acceptedLicenses" must be a list (${config.acceptedLicenses}).`);
	}
	if (config.manualOverrides && typeof config.manualOverrides !== 'object') {
		handleError(`${configFilePath}: "manualOverrides" must be an object (${config.manualOverrides}).`);
	}
	config.packageManager = config.packageManager || 'npm';
	projectPackage = JSON.parse(fs.readFileSync(path.join(projectDir, config.packageManager === 'bower' ? 'bower.json' : 'package.json')));
	config.acceptedLicenses = config.acceptedLicenses || [];
	config.acceptedScopes = config.acceptedScopes || [];
	config.manualOverrides = config.manualOverrides || {};
	config.ignoreUnusedManualOverrides = config.ignoreUnusedManualOverrides || false;
	let partitions = _.partition(config.acceptedLicenses, (license) => { // eslint-disable-line consistent-return
		if (spdx.valid(license)) {
			return true;
		} else if (spdxExceptions.indexOf(license) >= 0) {
			return false;
		}
		handleError(`${configFilePath}: "${license}" is not a valid SPDX license ID or one of (${spdxExceptions}).`);
	});
	acceptedSpdxExpr = config.acceptedLicenses.length > 0 ? '(' + _.join(partitions[0], ' OR ') + ')' : undefined;
	acceptedNonSpdx = partitions[1].concat('Project-Owner');
}

function checkLicense(licenseString, packageString) {
	if (licenseString.length === 0) {
		return false;
	}
	/* use this code if you want to accept guessed packages
	if (licenseString[licenseString.length - 1] === '*') {
		licenseString = licenseString.substring(0, licenseString.length - 1);
	} */
	return (
		(acceptedSpdxExpr && spdx.valid(licenseString) && satisfies(licenseString, acceptedSpdxExpr))
		|| acceptedNonSpdx.indexOf(licenseString) >= 0
		|| packageString.startsWith(projectPackage.name + '@') // accept your own package
		|| _.some(config.acceptedScopes, (scope) => packageString.startsWith(`@${scope}/`))
	);
}

class ManualOverrideHelper {
	constructor(manualOverrides) {
		this._packages = new Map();
		this._unchecked = new Set();

		const keys = Object.keys(manualOverrides);
		for (const key of keys) {
			// Start at 1 to handle scopes (e.g. "@d2l/license-checker-ci@^1.0.0")
			const delimiterIndex = key.indexOf('@', 1);
			if (delimiterIndex < 0) {
				console.error(`WARNING: Manual override "${key}" could not be parsed as "[@scope/]module@version".`);
				continue;
			}

			const name = key.slice(0, delimiterIndex);
			const version = key.slice(delimiterIndex + 1);
			const range = semver.validRange(version);
			if (range === null) {
				console.error(`WARNING: Manual override "${key}" does not have a well-formed version.`);
				continue;
			}

			let ranges = this._packages.get(name);
			if (ranges === undefined) {
				ranges = new Map();
				this._packages.set(name, ranges);
			}

			if (ranges.has(range)) {
				const conflict = ranges.get(range);
				console.error(`WARNING: Manual overrides "${key}" conflicts with "${conflict.key}" over "${range}".`);
				continue;
			}

			const data = {
				name, version, key,
				license: manualOverrides[key]
			};
			ranges.set(range, data);
			this._unchecked.add(key);
		}
	}

	find(key) {
		const delimiterIndex = key.indexOf('@', 1);
		const name = key.slice(0, delimiterIndex);
		const version = key.slice(delimiterIndex + 1);
		const ranges = this._packages.get(name);
		if (ranges !== undefined) {
			for (const [range, data] of ranges) {
				if (semver.satisfies(version, range)) {
					this._unchecked.delete(data.key);
					return data.license;
				}
			}
		}
		return null;
	}

	get unchecked() {
		return Array.from(this._unchecked);
	}
}

function processLicenseCheckerOutput(json) {
	let fail = false;
	const manualOverrideHelper = new ManualOverrideHelper(config.manualOverrides);
	_.forEach(json, (value, key) => {
		// When the licenses are provided as an array by bower-license, always use the first string
		let license = manualOverrideHelper.find(key) ||
			(Array.isArray(value.licenses) ? value.licenses[0] : value.licenses);
		if (!checkLicense(license, key)) {
			fail = true;
			console.error(
				`>>> Package "${key}" doesn\'t meet license requirements (${license}).\n` +
				`    Repository: ${value.repository}\n`
			);
		}
	});
	if (!config.ignoreUnusedManualOverrides) {
		manualOverrideHelper.unchecked.forEach((override) => {
			console.error(`WARNING: Manual override "${override}" is never used, consider removing it.\n`);
		});
	}

	if (fail) {
		handleError(
			'Some licenses didn\'t pass the requirements (see above).\n' +
			`Please check the offending packages or update the configuration file (${defaultConfigFilePath}).\n` +
			'You can find more information at https://github.com/Brightspace/license-checker-ci', 2);
	} else {
		console.log('All licenses passed the check.');
	}
}

function main() {
	readConfig();
	const licenseChecker = {
		'npm': () => {
			const npmChecker = Promise.promisify(checker.init);
			// the semantics of our arguments are different than license-checker (see their --help)
			return npmChecker({
				start: projectDir
			});
		},
		'bower': () => new Promise((resolve, reject) => {
			bowerChecker.init(projectPackage, (licenseMap, err) => {
				if (err) {
					return reject(err);
				} else {
					return resolve(licenseMap);
				}
			});
		})
	};

	return licenseChecker[config.packageManager]()
		.catch(err => handleError('license-checker did not run successfully. Details:\n' + JSON.stringify(err)))
		.then(json => processLicenseCheckerOutput(json))
		.catch(err => handleError('Uncaught exception. Details:\n' + JSON.stringify(err)));
}

main();
